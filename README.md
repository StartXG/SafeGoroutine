# 协程资源保护在银行交易场景下的模拟案例

> 本项目是一个简单的RPC服务端和客户端的例子，通过互斥锁保护共享资源，模拟银行账户的存取款操作。

不同的分支表达了不同的实现方式：

- `main/mutex` 分支：使用 `sync.Mutex` 互斥锁保护共享资源（已实现）
- `rwlock` 分支：使用 `sync.RWMutex` 读写锁保护共享资源（已实现）
- `channel` 分支：使用 `channel` 通道保护共享资源
- `atomic` 分支：使用 `sync/atomic` 原子操作保护共享资源（已实现）

---

- `cond` 分支：使用 `sync.Cond` 条件变量保护共享资源，业务层面上的，在外部达成某种外部条件时允许修改共享资源
- `pool` 分支：不是`sync.Pool`，是 `协程池` 的实现，用于控制并发量

## 1. 项目背景

在银行交易场景下，多个线程对同一个账户进行存取款操作时，可能会出现数据不一致的情况。为了保证数据的一致性，需要使用互斥锁来保护共享资源。（已实现）

客户端的日志是乱序的，建议查看服务端的日志。

### server

- 启动RPC服务端
- 通过互斥锁保护模拟账户的存取款操作【这里是用的全局变量模拟】
- 禁止交易额余额为负数

### client

- 启动RPC客户端
- 模拟多个客户端对同一个账户进行存取款操作【gorouting 并发模拟账户在多地发生交易,10000的并发模拟】
- 通过RPC调用server端的存取款操作

## 2. 本地运行

> 本地运行需要安装Protobuf，如果没有安装，请先安装。

```shell
cd SafeGoroutine
go mod tidy

sh protoGen.sh

# server
go run server/main.go

# client
go run client/main.go 
```
